Here is an example of how you might set up your `main.yml` in the `.github/workflows` directory to automate testing and deployment with GitHub Actions and Docker.

```yaml
name: CI/CD pipeline
on: [push]
jobs:
  build-and-test:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
      
      - name: Set up Python
        uses: actions/setup-python@v2
        with:
          python-version: 3.8
          
      - name: Install Dependencies
        run: |
          python -m pip install --upgrade pip
          pip install flask psycopg2 flask_login requests
      
      - name: Lint with flake8
        run: |
          pip install flake8
          # stop the build if there are Python syntax errors or undefined names
          flake8 . --count --select=E9,F63,F7,F82 --show-source --statistics
          # exit-zero treats all errors as warnings. The GitHub editor is 127 chars wide
          flake8 . --count --exit-zero --max-complexity=10 --max-line-length=127 --statistics
      
      - name: Test with pytest
        run: |
          pip install pytest
          pytest

  deploy:
    needs: [build-and-test]
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
      
      - name: Set up Docker Buildx
        id: buildx
        uses: docker/setup-buildx-action@v1
        
      - name: Login to GitHub Packages Docker Registry
        uses: docker/login-action@v1 
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
          
      - name: Build and push Docker image to GitHub Packages
        uses: docker/build-push-action@v2
        with:
          context: .
          file: ./Dockerfile
          push: true
          tags: ghcr.io/${{ github.repository }}:latest
```

This workflow performs the following actions:

1. `build-and-test`: This job installs dependencies, checks code with flake8 and pytest. It will only proceed if all tests pass.
2. `deploy`: After successful testing, this job builds a Docker image from the Dockerfile in your repository and pushes it to GitHub's Container registry. You need to replace the Dockerfile path with the actual path of your Dockerfile.

This is just an example and you might need to adjust based on your specific project requirements, like database setup, secret management, etc. For instance, if you are using a PostgreSQL database in your Flask application, you would need to set up that as well in this workflow. Similarly, the Dockerfile should be written with all these requirements included.


